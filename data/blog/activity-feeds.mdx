---
title: How to do activity feeds
description: There are a couple of different approaches to building a standard activity feed for your application. Here's the way I like best.
date: '2021-11-13'
---

# How to do an activity feed

By _activity feed_, I mean something like this, from Vercel:

<Image src="/2021-11/activity-feed.png">
  The activity feed over on Vercel
</Image>

They're a basic staple of most applications with a lot of business logic: some auditable feed of things that have happened on the application, usually with the associated user and some content. They're usually user-facing, unlike e.g. log entries, which are usually consumed by some other system.

Everything below continues to work with the activity feed from Vercel, but I think it's all equally applicable to something as complex as e.g. a Facebook post.

## How not to do an activity feed
First: how _not_ to do an activity feed: don't just save the individual feed items as strings in a `TEXT` column in your database. We might create a new activity feed item like this:

```js
feed.createEntry('<a href="/users/1">Charles Harries</a> signed in on Safari');
```

Which corresponds to a database structure something like this:

|`id`|`content`|
|:-|:-|
|`1`|`<a href="/users/1">Charles Harries</a> signed in on Safari`|
|`2`|`Charles Harries started a deploy`|

> Timestamps are implied hereâ€”an activity log isn't very valuable if it doesn't keep track of _when_ things happen.

The first and most obvious issue here is that, while this feed is nice to read as a user, it's not parseable by a computer at all, which means we can't run data analysis or proper search on it. We're also stuck with the routing: we better hope that our user route is going to stay as `/users/1` forever, or that we have the presence of mind to set up all of the redirects we need.

A slightly better solution adds a `user_id` to our table, so we can keep track of which user performed which feed item in a searchable and filterable way:

```js
feed.createEntry({
    user_id: currentUser.id,
    content: 'signed in on Safari',
});
```

Which yields:

|`id`|`user_id`|`content`|
|:-|:-|:-|
|`1`|`1`|`signed in on Safari`|
|`2`|`1`|`started a deploy`|

This is... better, since it means that our routing can be managed in a template or something, where it belongs. But it sort of feels like only half a solution. What if our user is performing an action on some other modelâ€”like deploying a site? We can't just whack a `site_id` column into our database, though, since some feed items, like logins, won't pertain to sites.

So where do we go from here?

## Starting from data
When it comes down to it, almost all activity feed items like this are effectively made up of **data**, all joined together by prepositions and conjuctions and articles and stuff. `X` did `Y` to `Z` with `A` and `B`. `charlesharries deployed charles-harries-site to production`. So it makes a lot more sense to start with a data object, add some kind of identifier, and let the application assemble them on the fly.

```js
feed.createEntry('deploy', {
    user_id: currentUser.id,
    site_id: site.id,
    environment: 'production',
})
```

And in our templates:

```handlebars
<a href="/users/{{ user_id }}">{{ users[user_id] }}</a> deployed {{ sites[site_id] }} to {{ environment }}
```

This gives us the option, later, of changing our routingâ€”or our entire feed item messageâ€”around, if we feel like it. This is also a lot more parseable to other systems: we could create an application that digests this data and let us know who our application's most active users are, or how many deploys occur per week.

Counterintuitively, I think that this solution actually becomes _more_ obvious the more complex your log messages get. For small feed messages like the above, the `id`-and-`content`-columns approach might work for you (unwieldy though it is), but when you get to full Facebook posts, you're probably already structuring your data and letting your templating language manage the actual output. Funny how that works <Emoji>ðŸ¤”</Emoji>

## An alternative
I'm using Vercel as an example above, but it turns out that Vercel does logs slightly differently. They return the plain string along with a set of data objects that highlight substrings to alter in some way:

<Image src="/2021-11/vercel-logs.png">
  The JSON structure of Vercel's activity feed
</Image>

I don't know how this is stored in their database; I suspect there's something clever and not immeditately obvious going on under the hood here. I'm not a huge fan of clever solutions, but I'm confident that Vercel has some pretty smart folks behind this approach, so I'm not ruling it out.

Still a bigger fan of the data-led solution though. Keep your concerns separated, folks.

## Activity feeds are important, it turns out
For something so fundamental to complex applications, I'm surprised this isn't taught more often. In fact, I don't think I've seen this written down anywhereâ€”which is why I'm writing it here. Keeping a good, accurate, flexible, and parseable activity log gives us, and the users of our applications, a _ton_ more insight into the ways that things work and have worked in the pastâ€”so why aren't we putting more effort into making sure that they're done right?